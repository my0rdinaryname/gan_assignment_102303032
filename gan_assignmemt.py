# -*- coding: utf-8 -*-
"""Untitled24.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18LxkZ3yJpSJ5wJNe5n6-XohQB_VIQV8j
"""

import pandas as pd
import numpy as np
import os

# Load dataset
df = pd.read_csv("data.csv", encoding='cp1252')
print(df.columns)

# Extract NO2 concentration column
x = df["no2"].dropna().values

# Transformation parameters
a = 3.0
b = 0.9

# Transform x -> z
z = x + a * np.sin(b * x)

# Normalize (important for GAN stability)
z = (z - z.mean()) / z.std()

# Create directory if it doesn't exist
os.makedirs("../data/", exist_ok=True)
np.save("../data/z_data.npy", z)

import tensorflow as tf
from tensorflow.keras import layers

def build_generator():
    model = tf.keras.Sequential([
        layers.Dense(32, activation='relu', input_shape=(1,)),
        layers.Dense(32, activation='relu'),
        layers.Dense(1)
    ])
    return model

def build_discriminator():
    model = tf.keras.Sequential([
        layers.Dense(32, activation='relu', input_shape=(1,)),
        layers.Dense(32, activation='relu'),
        layers.Dense(1, activation='sigmoid')
    ])
    return model

import numpy as np
import tensorflow as tf

z_real = np.load("../data/z_data.npy")
z_real = z_real.reshape(-1, 1)

generator = build_generator()
discriminator = build_discriminator()

d_optimizer = tf.keras.optimizers.Adam(0.0002)
g_optimizer = tf.keras.optimizers.Adam(0.0002)

bce = tf.keras.losses.BinaryCrossentropy()

@tf.function
def train_step(real_samples):
    noise = tf.random.normal((len(real_samples), 1))

    with tf.GradientTape() as d_tape:
        fake_samples = generator(noise, training=True)
        real_output = discriminator(real_samples, training=True)
        fake_output = discriminator(fake_samples, training=True)

        d_loss = bce(tf.ones_like(real_output), real_output) + \
                 bce(tf.zeros_like(fake_output), fake_output)

    grads = d_tape.gradient(d_loss, discriminator.trainable_variables)
    d_optimizer.apply_gradients(zip(grads, discriminator.trainable_variables))

    with tf.GradientTape() as g_tape:
        fake_samples = generator(noise, training=True)
        fake_output = discriminator(fake_samples, training=True)
        g_loss = bce(tf.ones_like(fake_output), fake_output)

    grads = g_tape.gradient(g_loss, generator.trainable_variables)
    g_optimizer.apply_gradients(zip(grads, generator.trainable_variables))

    return d_loss, g_loss

epochs = 5000
batch_size = 64

for epoch in range(epochs):
    idx = np.random.randint(0, len(z_real), batch_size)
    d_loss, g_loss = train_step(z_real[idx])

    if epoch % 500 == 0:
        print(f"Epoch {epoch}: D={d_loss.numpy():.4f}, G={g_loss.numpy():.4f}")

# Save generator weights after training
generator.save_weights("generator_weights.weights.h5")

import tensorflow as tf
import numpy as np
import os

generator = build_generator()
generator.load_weights("generator_weights.weights.h5")

noise = tf.random.normal((10000, 1))
z_fake = generator(noise)

# Create directory if it doesn't exist (assuming results directory might not exist)
os.makedirs("../results/", exist_ok=True)
np.save("../results/z_fake.npy", z_fake.numpy())

import numpy as np
import matplotlib.pyplot as plt
from sklearn.neighbors import KernelDensity

z_fake = np.load("../results/z_fake.npy")

kde = KernelDensity(kernel='gaussian', bandwidth=0.3)
kde.fit(z_fake)

z_axis = np.linspace(z_fake.min(), z_fake.max(), 1000).reshape(-1,1)
pdf = np.exp(kde.score_samples(z_axis))

plt.plot(z_axis, pdf)
plt.title("Estimated PDF of z using GAN")
plt.xlabel("z")
plt.ylabel("p(z)")
plt.savefig("../results/pdf_estimate.png")
plt.show()